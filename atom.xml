<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[AaronPlay's Blog]]></title>
  <subtitle><![CDATA[想看清这个世界]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2014-11-07T09:08:54.980Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[aaronplay]]></name>
    <email><![CDATA[aaronplaywu@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java 基础 小结]]></title>
    <link href="http://yoursite.com/2014/11/07/Java-%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2014/11/07/Java-基础小结/</id>
    <published>2014-11-07T07:31:18.000Z</published>
    <updated>2014-11-07T09:05:27.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文是为了将新手常犯的错误地方总结出来，不详细展开。</p>
</blockquote>
<h3 id="抽象类与接口：">抽象类与接口：</h3>
<h4 id="抽象类">抽象类</h4>
<p>适用情况：当出现很多类拥有共同方法属性的时候，可以将它们共有的属性方法抽象出来，这样就形成了一个抽象类。</p>
<p>判定条件：只要类中出现抽象方法便可判定为抽象类。</p>
<h4 id="接口的扩展">接口的扩展</h4>
<p>使用情况：多重继承</p>
<p>特征：1.只能定义静态常量 2.方法默认为abstract</p>
<h3 id="匿名内部类">匿名内部类</h3>
<p>使用情况：某程度解决了多重继承的问题。匿名类的出现，使代码变得简洁很多。由于没有名字，所以有如下限制。</p>
<p>注意：</p>
<p>1.不能继承具体类 </p>
<p>2.只能实现一个接口。  如 <code>A a = new A(){ public method(){}};</code>，就定义了一个匿名内部类。</p>
<h3 id="设计模式">设计模式</h3>
<p>1.注意单例模式的并发问题。</p>
<h3 id="Collection">Collection</h3>
<ul>
<li><p>Collection是接口，Collections是具体类。</p>
</li>
<li><p>Collection与Map之间的UML图（来源：<a href="http://blog.csdn.net/bjyfb/article/details/8426030" target="_blank" rel="external">http://blog.csdn.net/bjyfb/article/details/8426030</a>）：<br><img src="http://aaronplayblog.qiniudn.com/Collection.png" alt=""></p>
</li>
<li><p>Set与Map的区别：1.Set不允许重复，Map允许。 2.实现接口不同，Set实现的为Cellection，Map实现的是Map接口。</p>
</li>
<li><p>Hashtable与HashMap的区别：1.HashMap，不存在分类和排序方法，所以允许一个null键和多个null值；而Hashtable是不允许的。 2.Hashtable里面的方法有Synchronize，HashMap则没有。 3.Hashtable由于需要同步速度较慢，反之HashMap较快。</p>
</li>
<li><p>Collection FramWork的结构：</p>
<p>  Collection<br>  ├List<br>  │├LinkedList<br>  │├ArrayList<br>  │└Vector<br>  │　└Stack<br>  └Set –hashset-Linkedhashset</p>
<pre><code>  -<span class="ruby"><span class="constant">Treeset</span></span>
</code></pre><p>  Map<br>  treemap<br>  ├Hashtable<br>  ├HashMap –WeakHashMap</p>
<pre><code>       -<span class="ruby"><span class="constant">Linkedhashmap</span> </span>
</code></pre></li>
</ul>
<h3 id="线程">线程</h3>
<p>状态图（来源：<a href="http://www.tuicool.com/articles/7Vn26j" target="_blank" rel="external">http://www.tuicool.com/articles/7Vn26j</a>,这篇博文推荐一看）：</p>
<p><img src="http://aaronplayblog.qiniudn.com/java_thread_state.png" alt=""></p>
<ul>
<li><p>stop()方法以及suspend()不建议使用。stop方法是暴力停止线程，会造成很多不可知的影响。suspend不释放资源，会造成死锁。</p>
</li>
<li><p>推荐设置标志位和使用wait() / notify()、notifyAll()</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文是为了将新手常犯的错误地方总结出来，不详细展开。</p>
</blockquote>
<h3 id="抽象类与接口：">抽象类与接口：</h3>
<h4 id="抽象类">抽象类</h4>
<p>适用情况：当出现很多类拥有共同方法属性的时候，可]]>
    </summary>
    
      <category term="深度：2" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%EF%BC%9A2/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android功能模块]]></title>
    <link href="http://yoursite.com/2014/10/29/Android-functions/"/>
    <id>http://yoursite.com/2014/10/29/Android-functions/</id>
    <published>2014-10-29T14:52:45.000Z</published>
    <updated>2014-10-29T15:16:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Android功能抽象">Android功能抽象</h1>
<blockquote>
<p>当你在有一定的项目累积之后，很自然地会有这样的想法。其实软件不外乎由两个模块组成，UI+功能模块。当然两个模块只是大类，每个模块的实现可是博大精深。本文主要是针对Android一些常用的功能做整理。游戏类和工具类均不太熟悉，先来个轻描淡写。</p>
</blockquote>
<h1 id="应用类">应用类</h1>
<h2 id="CRM"><strong>CRM</strong></h2>
<p>这个可以涵盖大部分应用，基本的加减乘除逻辑配合数据库就能实现。</p>
<h3 id="评论">评论</h3>
<h3 id="点赞">点赞</h3>
<h2 id="照片">照片</h2>
<h3 id="照片墙">照片墙</h3>
<p>现在滤镜等美化工具已经是标配</p>
<h2 id="分享">分享</h2>
<h2 id="通讯">通讯</h2>
<h2 id="推送">推送</h2>
<h2 id="语音">语音</h2>
<h2 id="地理信息位置">地理信息位置</h2>
<h2 id="阅读">阅读</h2>
<h2 id="音乐">音乐</h2>
<h2 id="传感器类">传感器类</h2>
<h3 id="gps">gps</h3>
<h3 id="电子罗盘">电子罗盘</h3>
<h3 id="摄像头">摄像头</h3>
<h4 id="二维码">二维码</h4>
<p>这个很常用，通过二维码很容易把虚拟跟现实结合起来。</p>
<h4 id="笑脸识别">笑脸识别</h4>
<h3 id="闪光灯">闪光灯</h3>
<h1 id="游戏类">游戏类</h1>
<h2 id="重力感应">重力感应</h2>
<h1 id="工具类">工具类</h1>
<p>这个涉及到底层比较多</p>
<h2 id="rom的定制">rom的定制</h2>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Android功能抽象">Android功能抽象</h1>
<blockquote>
<p>当你在有一定的项目累积之后，很自然地会有这样的想法。其实软件不外乎由两个模块组成，UI+功能模块。当然两个模块只是大类，每个模块的实现可是博大精深。本文主要是针对Andro]]>
    </summary>
    
      <category term="功能模块" scheme="http://yoursite.com/tags/%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/"/>
    
      <category term="深度：1" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%EF%BC%9A1/"/>
    
      <category term="Android functions" scheme="http://yoursite.com/categories/Android-functions/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android PhotoWall]]></title>
    <link href="http://yoursite.com/2014/10/28/Android-PhotoWall/"/>
    <id>http://yoursite.com/2014/10/28/Android-PhotoWall/</id>
    <published>2014-10-28T15:29:38.000Z</published>
    <updated>2014-10-30T06:43:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="图片墙——通过网络加载">图片墙——通过网络加载</h2>
<h3 id="UI">UI</h3>
<p>图片墙常用的就是通过一个<code>GridView</code>+<code>Adapter</code>来定制的内部格式。</p>
<pre><code><span class="tag">&lt;<span class="title">GridView</span>&gt;</span>
    //RelativeLayout是通过Adapter的getView来获得
    <span class="tag">&lt;<span class="title">RelativeLayout</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span>
<span class="tag">&lt;/<span class="title">GridView</span>&gt;</span>
</code></pre><h3 id="Adapter">Adapter</h3>
<p>基本用法：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">photoWallAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">OnScrollListener</span></span>{

<span class="keyword">public</span> <span class="title">photoWallAdapter</span>(){
    ...
}

<span class="keyword">public</span> <span class="title">getView</span>(){
    ...
}

}
</code></pre><h3 id="实现网络加载："><strong>实现网络加载：</strong></h3>
<p>1.异步下载</p>
<ul>
<li>使用<code>AsyncTask</code>下载</li>
<li>通过<code>Set</code>管理线程词</li>
</ul>
<p>2.分布加载</p>
<ul>
<li>通过 <code>onScroll</code> 加载当前页面的 position</li>
<li>根据<code>onScrollStateChanged</code>的状态来决定是否加载， 但静止状态时启动线程进行下载；当运动时取消所有线程下载。 </li>
</ul>
<p>3.缓存</p>
<ul>
<li>通过LruCache来存储图片。</li>
</ul>
<h3 id="Bitmap编码方法">Bitmap编码方法</h3>
<h4 id="通过BitmapFactory-方法">通过<code>BitmapFactory.方法</code></h4>
<p>使用范围广，可用于制定file，inputstream…等多种方式。</p>
<h4 id="android-provider-MediaStore-Images-Media-getBitmap(ContentResolver_cr,_Uri_url)_链接：http://developer-android-com/">android.provider.MediaStore.Images.Media.getBitmap(ContentResolver cr, Uri url) 链接：<a href="http://developer.android.com/reference/android/provider/MediaStore.Images.Media.html" target="_blank" rel="external">http://developer.android.com/</a></h4>
<p>使用频率并不高。</p>
<hr>
<p>感谢：郭神</p>
<p>参考：<a href="http://blog.csdn.net/guolin_blog/article/details/9526203" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/9526203</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="图片墙——通过网络加载">图片墙——通过网络加载</h2>
<h3 id="UI">UI</h3>
<p>图片墙常用的就是通过一个<code>GridView</code>+<code>Adapter</code>来定制的内部格式。</p>
<pre><code>]]>
    </summary>
    
      <category term="深度：1" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%EF%BC%9A1/"/>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jekyll to hexo]]></title>
    <link href="http://yoursite.com/2014/10/28/hexoblog/"/>
    <id>http://yoursite.com/2014/10/28/hexoblog/</id>
    <published>2014-10-28T00:18:06.000Z</published>
    <updated>2014-10-28T00:18:39.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原因">原因</h3>
<blockquote>
<p>由于之前的jekyll的主题的markdown格式支持不是很好，发现hexo做静态博客更加漂亮，然后转用hexo进行博客撰写。</p>
</blockquote>
<h3 id="HEXO背景">HEXO背景</h3>
<p>该项目是由台湾一学生用<strong>node.js</strong>完成的框架，实在让人佩服。</p>
<h3 id="搭建过程">搭建过程</h3>
<p>按照<a href="http://www.jianshu.com/p/05289a4bc8b2#" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a>基本可以完成hexo搭建。而他附带的博文，很值得一看。</p>
<h3 id="环境">环境</h3>
<blockquote>
<p>教程对环境的要求也是很高的，一旦<strong>软件版本</strong>进行大革新，适配路径、命令更改等问题会导致无法顺利完成按照，所以建议找最新的教程来的进行搭建。</p>
</blockquote>
<p>本机搭建环境：</p>
<ul>
<li>win8.1</li>
<li>node 1.4.28</li>
<li>hexo 2.8.3</li>
</ul>
<h3 id="遇到问题">遇到问题</h3>
<p><strong>npm的版本的问题</strong></p>
<p>由于教程的npm是旧版本，我执行<code>hexo s</code>后显示</p>
<pre><code>&lt;<span class="variable">%-</span> partial(<span class="string">'_partial/head'</span>) <span class="variable">%&gt;</span>
&lt;<span class="variable">%-</span> partial(<span class="string">'_partial/header'</span>, null, {cache: !config.relative_link}) <span class="variable">%&gt;</span>
&lt;<span class="variable">%-</span> body <span class="variable">%&gt;</span>
&lt;% <span class="keyword">if</span> (theme.sidebar &amp;&amp; theme.sidebar !== <span class="string">'bottom'</span>){ <span class="variable">%&gt;</span> &lt;<span class="variable">%-</span> partial(<span class="string">'_partial/sidebar'</span>, null, {cache: !config.relative_link}) <span class="variable">%&gt;</span> &lt;% } <span class="variable">%&gt;</span>
&lt;<span class="variable">%-</span> partial(<span class="string">'_partial/footer'</span>, null, {cache: !config.relative_link}) <span class="variable">%&gt;</span>
&lt;<span class="variable">%-</span> partial(<span class="string">'_partial/mobile-nav'</span>, null, {cache: !config.relative_link}) <span class="variable">%&gt;</span> &lt;<span class="variable">%-</span> partial(<span class="string">'_partial/after-footer'</span>) <span class="variable">%&gt;</span>    
</code></pre><blockquote>
<p>缺少选中模块。</p>
</blockquote>
<p><img src="http://aaronplayblog.qiniudn.com/npm.png-watermark" alt=""></p>
<p>原因：新版本对npm进行的简化，不必要的删减。需要另外安装软件。</p>
<p>在根目录执行<code>npm install</code>即可。</p>
<h3 id="补充">补充</h3>
<p><strong>关于图片：</strong>由于github page 空间限制为300m，所以可使用<a href="http://www.qiniu.com/" target="_blank" rel="external">七牛</a>作为其图床对图片进行管理。</p>
<p><strong>关于godaddy:</strong>淘宝可能会淘到更便宜的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原因">原因</h3>
<blockquote>
<p>由于之前的jekyll的主题的markdown格式支持不是很好，发现hexo做静态博客更加漂亮，然后转用hexo进行博客撰写。</p>
</blockquote>
<h3 id="HEXO背景">HEXO背景]]>
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IT能力表]]></title>
    <link href="http://yoursite.com/2014/10/27/skills-strength/"/>
    <id>http://yoursite.com/2014/10/27/skills-strength/</id>
    <published>2014-10-27T10:28:07.000Z</published>
    <updated>2014-10-27T10:31:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="能力">能力</h2>
<h3 id="编程">编程</h3>
<ul>
<li>Java：<em>**</em>（4）</li>
<li>Android：<em>**</em>（4）</li>
<li>JSP: **(2)</li>
<li>HTML+CSS:*(1) </li>
<li>C/C++ ：**（2）</li>
<li>算法&amp;数据结构：**（2）</li>
<li>DataBase：**（2）</li>
<li>Linux: *(1)</li>
</ul>
<h3 id="原理">原理</h3>
<ul>
<li>操作系统：**（2）</li>
<li>Android内核：<em>*</em>（3）</li>
<li>数据库：**（2）</li>
<li>计算机网络：**（2） </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="能力">能力</h2>
<h3 id="编程">编程</h3>
<ul>
<li>Java：<em>**</em>（4）</li>
<li>Android：<em>**</em>（4）</li>
<li>JSP: **(2)</li>
<li>HTML+CSS:*]]>
    </summary>
    
      <category term="能力" scheme="http://yoursite.com/categories/%E8%83%BD%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多线程探究]]></title>
    <link href="http://yoursite.com/2014/10/27/operation-system/"/>
    <id>http://yoursite.com/2014/10/27/operation-system/</id>
    <published>2014-10-27T10:28:07.000Z</published>
    <updated>2014-10-27T10:31:18.000Z</updated>
    <content type="html"><![CDATA[<p>背景：一个进程可以存在多个线程，线程可使用进程中的资源（内存栈），线程的里的资源独有，线程间可进行通信。</p>
<h5 id="线程状态：">线程状态：</h5>
<ol>
<li>派生</li>
<li>阻塞</li>
<li>解除阻塞</li>
<li>结束</li>
</ol>
<h3 id="一个进程里面存在多个线程，这个时候会将会出现几个问题：">一个进程里面存在多个线程，这个时候会将会出现几个问题：</h3>
<p>1.<strong>同步问题</strong></p>
<p>两个或以上的线程对同一个资源进行操作的时候，如读写操作。会导致数据的异常情况的出现（如，读发生在写之前）。</p>
<p>解决办法：使用锁</p>
<p>2.<strong>资源分配问题</strong></p>
<p>每个线程的完成，需要依赖于一定的资源，而在进程里面，对于单个线程来说，资源是足够的，但是多个线程的就不一定了，当各个线程同时持有的资源又不再获得新的资源，会导致<strong>死锁</strong>的发生。</p>
<p>解决办法：死锁的预防、检测、恢复。</p>
<h3 id="线程间通信">线程间通信</h3>
<p>用于：流水线式模块并发处理，资源之间有依赖关系（生产者——消费者）…</p>
<ol>
<li>管道</li>
<li>信号量</li>
<li>信号</li>
<li>共享内存</li>
<li>消息（Message）</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>背景：一个进程可以存在多个线程，线程可使用进程中的资源（内存栈），线程的里的资源独有，线程间可进行通信。</p>
<h5 id="线程状态：">线程状态：</h5>
<ol>
<li>派生</li>
<li>阻塞</li>
<li>解除阻塞</li>
<li>结束</li>]]>
    </summary>
    
      <category term="深度：*" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%EF%BC%9A/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[blog upload]]></title>
    <link href="http://yoursite.com/2014/10/27/build-blog/"/>
    <id>http://yoursite.com/2014/10/27/build-blog/</id>
    <published>2014-10-27T10:28:07.000Z</published>
    <updated>2014-10-27T10:31:52.000Z</updated>
    <content type="html"><![CDATA[<h3 id="build_up_the_blog_with_jekyll">build up the blog with jekyll</h3>
<pre><code>It <span class="keyword">is</span> really funny <span class="keyword">to</span> <span class="keyword">write</span> <span class="keyword">in</span> markdown. 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="build_up_the_blog_with_jekyll">build up the blog with jekyll</h3>
<pre><code>It <span class="keyword">is</span> really funny <span c]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[ADB浅尝]]></title>
    <link href="http://yoursite.com/2014/10/27/ADB/"/>
    <id>http://yoursite.com/2014/10/27/ADB/</id>
    <published>2014-10-27T10:28:07.000Z</published>
    <updated>2014-10-27T11:20:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>Android debug Bridge(ADB)在处于在<sdk>/platform-tools/文件夹下，在该文件夹下也有很多常用的Android开发工具，详情查看<a href="http://developer.android.com/tools/help/index.html" target="_blank" rel="external">Android developer</a>。由它的名字可以知道，adb用作开发者在PC端调试Android实例的（具体模块操作如下图），通过命令行（类似linux）进行操作的。</sdk></p>
<p><img src="/img/raw/2014-10-27/adb.png" alt=""></p>
<p>从图中可看出，adb是由serve进行中央调度管理。</p>
<h3 id="语法">语法</h3>
<pre><code>//就是一个脚本命令
adb [<span class="operator">-d</span>|<span class="operator">-e</span>|<span class="operator">-s</span> &lt;serialNumber&gt;] &lt;command&gt;
</code></pre><h3 id="用法">用法</h3>
<ul>
<li>查看模拟器/设备的实例状况</li>
<li>管理application(如，安装和删除)</li>
<li>端口管理。用于连接本地服务器，wifi等端口分配</li>
<li>文件的pull和push</li>
<li><strong>shell</strong>的运用<ul>
<li>activity manager (am)</li>
<li>package manager (pm)</li>
<li><a href="http://aaronplay.github.io/2014/10/Andorid-sqlite/" target="_blank" rel="external">sqlite3</a> 的远程使用</li>
<li>screenrecord(类似截图，不同是这个截的是视频),这个功能需要sdk 4.4以上才支持</li>
<li>UI/Application Monkey test。随机输入脉冲，进行压力测试</li>
<li>logat</li>
</ul>
</li>
</ul>
<p>ps：具体用法请浏览底端的参考页面。</p>
<h3 id="外置工具集成">外置工具集成</h3>
<p>思考，很多的外置工具是通过adb的工具进行集成的，如我们常用的log日志的输出。</p>
<hr>
<p>参考：<a href="http://developer.android.com/tools/help/adb.html" target="_blank" rel="external">http://developer.android.com/tools/help/adb.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="背景">背景</h3>
<p>Android debug Bridge(ADB)在处于在<sdk>/platform-tools/文件夹下，在该文件夹下也有很多常用的Android开发工具，详情查看<a href="http://developer.android]]>
    </summary>
    
      <category term="深度：*" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%EF%BC%9A/"/>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法与数据结构]]></title>
    <link href="http://yoursite.com/2014/10/27/alogrithm-structure/"/>
    <id>http://yoursite.com/2014/10/27/alogrithm-structure/</id>
    <published>2014-10-27T10:28:07.000Z</published>
    <updated>2014-10-27T11:21:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="算法与数据结构">算法与数据结构</h1>
<p>在leetcode 刷了69道面试出现的算法题，用了偷懒的方法（先思考，然后看答案的方式），但收获依然很大。不过还是建议通过“思考-&gt;写代码-&gt;测试-&gt;优化”的方式学习，收获会更大。接下来是我在leetcode刷题时的理解上对于算法以及数据结构的总结。    </p>
<blockquote>
<p><strong>本文目的：打造一个算法模板，把适用情况总结出来，以便快速定位，套用。</strong></p>
</blockquote>
<h2 id="算法">算法</h2>
<blockquote>
<p>思考：在解决问题的时候，我们都希望直接能达到最好的效果，但人的思考是从简单开始，再到复杂，之后慢慢优化，所以不存在最优的效果，只有在目前所在的状况达到最优的答案，以后会有更好的算法。</p>
</blockquote>
<p>基于计算机运算的操作，不外乎就是对数据的增删查改，而这个操作的前提是找到需要目标。</p>
<p><strong>注意好细节上处理，边界问题等，可以通过简单的举例来测试</strong></p>
<ul>
<li><p><strong>暴力法（枚举）</strong></p>
<p>  这是我们最容易想到，就是一个个地尝试，相当万能的解法，但这种情况只适用于在计算机强大的能力下。这样的代码一般都是很短的，读起来也是最省力了。但一般不用，因为计算机可以帮助我们做得更多。</p>
</li>
<li><p><strong>排序</strong></p>
<p>  在所有的算法中，排序是很关键的环节，排序对我们的数据进行一定的预处理，虽然需要耗掉一定的时间复杂度。但磨刀不误砍柴工这个道理我们不是不知道的:)</p>
<p>  排序的定义，可以理解为对无序的数据，进行有序（结构化）的处理，常用的有数组，还有更强大的数据结构，如链表，树等数据结构。</p>
<p>  但是我们一般说的是数组上排序，常见的排序见下表：</p>
<p>  <img src="/img/raw/2014-10-06/sort.png" alt=""></p>
<p>  使用频率较高的有快速排序，合理设置其元量可以减低最坏时间的时间复杂度。</p>
</li>
<li><p><strong>查找</strong></p>
<p>  为了更加高效地查找，我们一般在结构化的数据基础上进行查找。除非有特别的情况，否则已排序的数组的情况下，一般选用<strong>二分查找</strong>（能确保自己能正确写出来吗？）。</p>
</li>
</ul>
<p><em>以上算法适用于在单个目标的查找修改，对于数据之间有关联，或者是对数据之间进行运算，可以选择更加优秀的算法来提高的性能。</em></p>
<p>接下来，涉及到的算法按以下框架进行书写：</p>
<blockquote>
<p>原理：<br>适用情况：<br>实现框架：<br>例子：</p>
</blockquote>
<ul>
<li><p><strong>递归</strong></p>
<p>  原理：  根据目前的状况，等量改变参数，对自身函数进行调用。</p>
<p>  适用情况：可以把当前问题抽象以层次为单位进行解决的，层与层之间的状态有关联。</p>
<p>  实现框架：</p>
<pre><code>  &gt;1.设置收敛界限
  &gt;
  &gt;2.递归公式
</code></pre><p>  伪代码：</p>
<pre><code>  <span class="keyword">int</span> reserve(TreeNode* root){
          <span class="keyword">if</span>(root == nullptr) <span class="keyword">return</span> ; <span class="comment">//收敛边界</span>

          <span class="keyword">if</span>(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr ) <span class="keyword">return</span> root-&gt;val; <span class="comment">// 收敛边界</span>

          <span class="keyword">return</span> root-&gt;val + reserve(root-&gt;left) + reserve(root-&gt;right); <span class="comment">//递归公式 </span>
  }
</code></pre></li>
</ul>
<pre><code>例子：    二叉树的遍历，DFS
</code></pre><ul>
<li><p><strong>分治</strong>  </p>
<p>  原理：将大的目标分解成小的目标，逐个击破，然后归并。 </p>
<p>  适用情况：目标可以分解成子目标，子目标解决起来比较方便。而且有可能每个小目标不是没有关联的，会被重复利用。当遇到问题较为大型或复杂的时候要要考虑分而治之的方法。</p>
<p>  实现框架：通常由递归进行实现。</p>
<blockquote>
<p>在递归的基础上，把数据域缩小。</p>
</blockquote>
<p>  伪代码：</p>
<pre><code>  <span class="keyword">void</span> merge_sort(<span class="keyword">int</span> *<span class="built_in">list</span>, <span class="keyword">int</span> list_size){
      <span class="keyword">if</span>(list_size&gt;<span class="number">1</span>){ <span class="comment">// 收敛条件</span>
          <span class="comment">//分</span>
          <span class="keyword">int</span> *list1 = <span class="built_in">list</span>;
          <span class="keyword">int</span> list1_size = list_size / <span class="number">2</span>;
          <span class="keyword">int</span> *list2 = <span class="built_in">list</span> + list_size/<span class="number">2</span>;
          <span class="keyword">int</span> list2_size = list_size - list_size;

          merge_sort(list1,list_size1);
          merge_sort(list2,list_size2);

          <span class="comment">//归并</span>
          merge_array(list1,list_size1,list2,list_size2);
      }
  }
</code></pre><p>  例子：归并排序，数的拆分 11 = 3 + 3 + 3 + 2。</p>
</li>
</ul>
<ul>
<li><p><strong>回溯</strong></p>
<p>  原理：  若当前情况不合适时，回退到过去的某一个状态，进行另一种尝试。</p>
<p>  适用情况：暴力搜寻法，当得知当前情况不能得到的结果的时候，后退（几步），然后进行重新选择，一般与递归合用。</p>
<p>  实现框架：</p>
<blockquote>
<p>每次递归结束，恢复为之前的状态。</p>
</blockquote>
<pre><code>  int a[n];
  <span class="keyword">try</span>(int i){
      <span class="keyword">if</span>(i&gt;n)
          输出结果
      <span class="keyword">else</span>{
          <span class="keyword">for</span>(int j= 下界；j &lt;= 上界; ++j){
              <span class="keyword">if</span>(fun(j)) // 满足限界函数和约束条件
              {
                  a[i] = j;
                  <span class="keyword">...</span> // 其他操作
                  <span class="keyword">try</span>(i+<span class="number">1</span>);
                  <span class="keyword">...</span> // 清理，回溯工作
              }
          }
      }
  }
</code></pre><p>  例子：n皇后问题</p>
</li>
</ul>
<ul>
<li><strong>贪心</strong></li>
</ul>
<pre><code>原理：  在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所作的尽是某种意义上的局部最优解。

适用情况：局部最优解能决定全局最优解，全局问题由子问题做出抉择，不能回退结果（动态规划可以），一般得到的不是最优解。

实现框架：
&gt;从问题的某一初始解出发

    <span class="keyword">while</span>(能朝目标前进一步){
        利用可行的决策，求出可行解的一个元素；
    }
    由所有解元素组合成问题的一个可行解;

例子：背包问题
</code></pre><ul>
<li><strong>动态规划</strong></li>
</ul>
<pre><code>原理：全局解由局部最优解组成，每次的子问题都构造就进行一次决策。

适用情况：一种自顶向下的算法，每一步都在决策都跟之前的结果相关（递归公式），根据之前的结果，能回退。

实现框架：

    <span class="number">1.</span>构造辅助空间

    <span class="number">2.</span>初始化边界条件

    <span class="number">3.</span>递归公式

伪代码：    

    <span class="keyword">for</span>(<span class="built_in">j</span> = <span class="number">1</span>; <span class="built_in">j</span> &lt;= m ; ++<span class="built_in">j</span>)
        xn<span class="matrix">[j]</span> = 初始值;

    <span class="keyword">for</span>(<span class="built_in">i</span> = n-<span class="number">1</span>;<span class="built_in">i</span>&gt;=<span class="number">1</span>;<span class="built_in">i</span> = <span class="built_in">i</span>-<span class="number">1</span>)
        <span class="keyword">for</span>(<span class="built_in">j</span> = <span class="number">1</span>;<span class="built_in">j</span>&gt;=f(<span class="built_in">i</span>);<span class="built_in">j</span> = <span class="built_in">j</span>+<span class="number">1</span>)
            x<span class="matrix">[i]</span><span class="matrix">[j]</span> = max()<span class="cell">{ 递推公式 };   

    result = x[<span class="number">1</span>][<span class="number">1</span>]

例子：<span class="number">01</span>背包问题</span>
</code></pre><p><strong>优化：</strong></p>
<ul>
<li><p><strong>空间换时间</strong>  </p>
<p>  hastable</p>
</li>
</ul>
<p>递归变种：</p>
<ul>
<li><strong>深度搜索DFS</strong></li>
</ul>
<pre><code>原理：一层一层地往下寻找，到底之后，换另一个支路继续挖。

适用情况：给定初始状态跟目标状态，要求判断初始状态跟目标状态是否有解。

实现框架：
    递归版，如上面的递归算法。

    非递归:

    通过栈来存储分支未访问节点


例子：图类的应用
</code></pre><ul>
<li><p><strong>广度搜索BFS</strong></p>
<p>  原理：先遍历当前层所有节点，再遍历下一层</p>
<p>  适用情况：给定初始状态跟目标状态，要求判断初始状态跟目标状态是否有解。（同上），区别在于不知目标深度的时候，会陷入无穷分支。</p>
<p>  实现框架：</p>
<pre><code>  递归版，如上面的递归算法。

  非递归:

  1.定义两个队列q1、q2

  2.把根结点放在q1

  3.当前节点的子结点放在q1，直到q1为空

  4.q2与q1交换，重复3，直到q1、q2均为空
</code></pre></li>
</ul>
<pre><code>例子：图类的应用
</code></pre><h2 id="数据结构">数据结构</h2>
<p>砍不同的树，选择不同的刀子，会有不同的效果。而<strong>数据结构</strong>就是我们的刀子，通过它们的特性，可以帮我们更好地解决问题。</p>
<p>基本数据结构有：</p>
<ul>
<li><p>数组</p>
<pre><code>  巧用：利用数组的下标，可以使信息量不大的二维数组转换为一维。  
</code></pre></li>
<li><p>链表</p>
<pre><code>  巧用：链表的强大主要在于指针上，通过改变指针的指向，可以像魔术师一样改变链表的结构。
</code></pre></li>
<li><p>二叉树</p>
<pre><code>  巧用：跟链表相像，可以改变叶结点的指针，从而改变整棵树的结构。
</code></pre></li>
<li><p>栈</p>
<pre><code>  特性：后进先出。
</code></pre></li>
<li><p>堆</p>
<pre><code>  常用：最大堆或最小堆的构造。
</code></pre><p>  数组和链表是很相似的数据结构，区别在于：</p>
<pre><code>  <span class="keyword">*</span><span class="keyword">*</span>空间<span class="keyword">*</span><span class="keyword">*</span>  
  数组：需要预分配，耗空间  
  链表：按需分配 

  <span class="keyword">*</span><span class="keyword">*</span>访问效率<span class="keyword">*</span><span class="keyword">*</span>  
  数组：支持随机访问  
  链表：不支持
</code></pre></li>
</ul>
<p>高级数据结构：</p>
<ul>
<li>哈希表</li>
<li>树（红黑树，Trie树，后缀树，红黑树，B树，R树）</li>
<li>图</li>
</ul>
<h2 id="常见时间复杂度的算法">常见时间复杂度的算法</h2>
<p>但即使计算机运算能力再强大，也不应该这样白白浪费这么优秀的资源。接下来，我们要从性能的角度去分析算法。这时候，需要引入一个标准以判断哪些算法性能更优，我们引入时间复杂度和空间复杂度，用<strong>O(A)</strong>表示，A表示为算法。</p>
<p>常用算法的时间复杂度：</p>
<ul>
<li><p>O(1)    </p>
<p>  基本运算 + - * / % 寻址</p>
<p>  hash表的期望复杂度</p>
</li>
<li><p>O(logn)</p>
<p>  二分查找</p>
</li>
<li><p>O(<code>n^(1/2</code>))</p>
<p>  枚举公约数</p>
</li>
<li><p>O(nlogn)  </p>
<p>  归并排序    </p>
<p>  快速排序期望复杂度</p>
<p>  基于比较排序的算法下界</p>
</li>
<li><p>O(<code>n^2</code>)</p>
<p>  集合里枚举所有二元组</p>
</li>
<li><p>O(<code>n^3</code>) </p>
<p>  集合里枚举所有三元组</p>
</li>
<li><p>O(<code>2^n</code>)</p>
<p>  枚举全部子集</p>
</li>
<li><p>O(n!)</p>
<p>  枚举全部排列</p>
</li>
<li><p>O(<code>n^n</code>)</p>
<p>  枚举n维数组的全部元素</p>
</li>
</ul>
<p>以上时间复杂度按照从小到大排列</p>
<p>O(n)能做的事太多，另开一个章节讨论。</p>
<h2 id="算法&amp;数据结构学习资源">算法&amp;数据结构学习资源</h2>
<p>《算法导论》、《编程之美》、《剑指offer》、<a href="http://blog.csdn.net/v_JULY_v" target="_blank" rel="external">july博客</a>、leetcode 题库</p>
<hr>
<p>参考：</p>
<p><a href="http://weibo.com/julyweibo" target="_blank" rel="external">july</a>的面试算法讲座ppt</p>
<p>leetcode 题库</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="算法与数据结构">算法与数据结构</h1>
<p>在leetcode 刷了69道面试出现的算法题，用了偷懒的方法（先思考，然后看答案的方式），但收获依然很大。不过还是建议通过“思考-&gt;写代码-&gt;测试-&gt;优化”的方式学习，收获会更大。接下来是我在l]]>
    </summary>
    
      <category term="alogrithm" scheme="http://yoursite.com/tags/alogrithm/"/>
    
      <category term="structure" scheme="http://yoursite.com/tags/structure/"/>
    
      <category term="base" scheme="http://yoursite.com/categories/base/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQL浅尝]]></title>
    <link href="http://yoursite.com/2014/10/27/SQL/"/>
    <id>http://yoursite.com/2014/10/27/SQL/</id>
    <published>2014-10-27T10:28:07.000Z</published>
    <updated>2014-10-27T10:32:05.000Z</updated>
    <content type="html"><![CDATA[<h3 id="SQL背景">SQL背景</h3>
<p>SQL（Structured Query Language,结构化查询语言），是IBM公司最早使用在数据库系统中。1986年美国国家标准学会（ANSI）对SQL进行规范之后，以此作为关系式数据库管理系统的标准语言，1987年成为国际标准。但不同数据库会对他进行扩充，所以不同数据库间会出现一个数据库出现一套SQL语句，但是差别不大。</p>
<h3 id="语言特点">语言特点</h3>
<p>SQL作为一种高级的非过程化语言，允许用户在高层数据数据结构上工作。</p>
<p>SQL同时也是数据库文件格式和扩展名。</p>
<p>SQL包含3个部分：</p>
<ol>
<li>DD(define)L     （常用）</li>
<li>DM(Manage)L   （常用）</li>
<li>DC(Control)L  </li>
</ol>
<h3 id="安全问题">安全问题</h3>
<p>许多开发人员习惯以字符串组合创建SQL指令，而且又使用<strong>系统管理员级</strong>的账号连接数据库，因此让黑客有机会利用SQL组合方式进行攻击（如，drop table;、 delete * from table;），这种攻击成为SQL注入。</p>
<p>预防方法：<a href="http://zh.wikipedia.org/wiki/%E5%8F%83%E6%95%B8%E5%8C%96%E6%9F%A5%E8%A9%A2" target="_blank" rel="external">参数化查询</a>（在Java中，就是利用占位符，然后进行替代）</p>
<h3 id="常用语句">常用语句</h3>
<p><strong>DML：</strong></p>
<ul>
<li><p>SELECT</p>
<pre><code>  <span class="operator"><span class="keyword">SELECT</span> * 
  <span class="keyword">FROM</span> 
  <span class="keyword">WHERE</span>
  <span class="keyword">GROUP</span>
  <span class="keyword">BY</span>
  <span class="keyword">ORDER</span>
  <span class="keyword">BY</span></span>
</code></pre></li>
</ul>
<ul>
<li><p>UPDATE</p>
</li>
<li><p>DELETE</p>
</li>
<li><p>INSERT INTO    </p>
</li>
</ul>
<p><strong>DDL：</strong></p>
<ul>
<li>CREATE DATABASE</li>
<li>ALTER DATABASE</li>
<li>CREATE TABLE</li>
<li>ALTER TABLE</li>
<li>DROP TABLE</li>
<li>CREATE INDEX</li>
<li>DROP INDEX</li>
</ul>
<h3 id="强化学习">强化学习</h3>
<p><a href="http://www.w3school.com.cn/sql/" target="_blank" rel="external">w3cschool</a></p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/SQL" target="_blank" rel="external">wiki</a></li>
<li><a href="http://www.w3school.com.cn/sql/sql_syntax.asp" target="_blank" rel="external">w3cschool</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="SQL背景">SQL背景</h3>
<p>SQL（Structured Query Language,结构化查询语言），是IBM公司最早使用在数据库系统中。1986年美国国家标准学会（ANSI）对SQL进行规范之后，以此作为关系式数据库管理系统的标准语言，1987]]>
    </summary>
    
      <category term="深度：*" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%EF%BC%9A/"/>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[招聘总结]]></title>
    <link href="http://yoursite.com/2014/10/27/Interview/"/>
    <id>http://yoursite.com/2014/10/27/Interview/</id>
    <published>2014-10-27T10:28:07.000Z</published>
    <updated>2014-10-27T10:31:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="笔试">笔试</h2>
<p>一般招移动岗位的笔试的题不会说专门针对Android、Java方面的知识点，除非招聘公司专门指出找Android开发工程师，否则一般都是的用最基础的考察题来测试你。<br>主要有以下：</p>
<ul>
<li>C/C++ 基本的知识作为考点，找错题。 —建议查看书籍《C++ Primer》、《深入C++对象模型》</li>
<li>数据结构和算法         —leetcode</li>
<li>计算机网络</li>
<li>操作系统</li>
<li>数据库</li>
<li>概率题等智力题</li>
</ul>
<h2 id="面试">面试</h2>
<p>面试对Android、Java 方面的考察较多，随着面试的关数增加，会增加对曾经做过项目进行深度挖掘。这时要注意对项目的常考的知识点进行巩固。由于Android没有相关Effective 系列，所以暂时还不好地准备面试官问的问题。</p>
<p>接下来总结一下《Effective Android》的书籍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="笔试">笔试</h2>
<p>一般招移动岗位的笔试的题不会说专门针对Android、Java方面的知识点，除非招聘公司专门指出找Android开发工程师，否则一般都是的用最基础的考察题来测试你。<br>主要有以下：</p>
<ul>
<li>C/C++ 基本的知识]]>
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[enum Java 探究]]></title>
    <link href="http://yoursite.com/2014/10/27/Enum-Learn/"/>
    <id>http://yoursite.com/2014/10/27/Enum-Learn/</id>
    <published>2014-10-27T10:28:07.000Z</published>
    <updated>2014-10-27T10:31:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、API描述">一、API描述</h2>
<p><a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="external">java API</a>：</p>
<pre><code>java.lang
        <span class="class"><span class="keyword">Class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span>
</code></pre><p>E表示E是一个enum实例</p>
<pre><code>java.lang.Object
     java.lang.Enum&lt;<span class="keyword">E</span>&gt;
Type Parameters:
    <span class="keyword">E</span> - The enum type subclass
<span class="keyword">All</span> Implemented Interfaces:
    Serializable, Comparable&lt;<span class="keyword">E</span>&gt;
</code></pre><hr>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;
    <span class="keyword">extends</span> <span class="title">Object</span>
<span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></span>
</code></pre><p>从构造器可看出</p>
<p>Modifier    Constructor and Description</p>
<pre><code><span class="keyword">protected</span>    Enum(<span class="keyword">String</span> name, int ordinal)
Sole <span class="function"><span class="keyword">constructor</span>.</span>
</code></pre><p>构造函数是String - int 分配，在实际使用中，不需要定义ordinal，默认是从0开始。</p>
<p>事例：</p>
<pre><code><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span>{BLACK,WHITE}
</code></pre><p>数据域为静态类型，估计是用set进行存储，所以只能实例化一次</p>
<p>所以<strong>通过enum来实现单例模式性能是很好而且很方便</strong></p>
<h2 id="二、不可继承性">二、不可继承性</h2>
<p>摘自《thingking in java》P594</p>
<pre><code><span class="keyword">enum</span> Explore{HERE,THERE}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> main(){
    OSExecute.command(<span class="string">"javap Explore"</span>);
}

<span class="comment">//结果：</span>
<span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Explore</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span></span>{
...
}
</code></pre><p>可见使用enum定义的类型都final，不可被继承。</p>
<h2 id="三、后续进阶">三、后续进阶</h2>
<p>EnumSet、EnumMap的使用</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、API描述">一、API描述</h2>
<p><a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="external">java API</a>：</p>
<pre><]]>
    </summary>
    
      <category term="深度：*" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%EF%BC%9A/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective Java]]></title>
    <link href="http://yoursite.com/2014/10/27/Effective-Java/"/>
    <id>http://yoursite.com/2014/10/27/Effective-Java/</id>
    <published>2014-10-27T10:28:07.000Z</published>
    <updated>2014-10-27T10:31:36.000Z</updated>
    <content type="html"><![CDATA[<p>有关Effective 系列的书籍是建立在一定的项目经验的基础进行总结的，同样的，读者最好的在有一定的项目经验后阅读较为容易理解，但是即使没有经验同样收获也不少，同样地在每次完成项目之后来看会有一个质变的效果。</p>
<h2 id="2_创建与销毁对象">2 创建与销毁对象</h2>
<ul>
<li>考虑静态工厂方法替代构造器</li>
<li>遇到多个构造器参数时需要考虑用构造器</li>
<li>用私有构造器或枚举类型强化Singleton属性</li>
<li>通过私有化构造器强化不可实例化的能力</li>
<li>避免创建不必要的对象</li>
<li>消除过期的对象引用</li>
<li>避免使用终结方法</li>
</ul>
<h2 id="3_对于所有对象都通用的方法">3 对于所有对象都通用的方法</h2>
<ul>
<li>覆盖equals时请遵守通用约定</li>
<li>覆盖equals时总要覆盖hashCode</li>
<li>始终要覆盖toString</li>
<li>谨慎地覆盖clone</li>
<li>考虑实现Comparable接口</li>
</ul>
<h2 id="4_类和接口">4 类和接口</h2>
<ul>
<li>使类和成员的可访问性最小化</li>
<li>在公有类中使用访问方法而非公有域</li>
<li>使可变性最小化</li>
<li>复合优于继承</li>
<li>要么为继承而设计，并提供文档说明，要么就禁止继承</li>
<li>接口优于抽象类</li>
<li>接口只用于定义类型</li>
<li>类层次优于便签类</li>
<li>用函数对象表示策略</li>
<li>优先考虑静态成员类</li>
<li>优先考虑类型安全的异构容器</li>
</ul>
<h2 id="5_泛型">5 泛型</h2>
<ul>
<li>请不要再新代码中使用原生态类型</li>
<li>消除非受检警告</li>
<li>列表优先于数组</li>
<li>优先考虑泛型</li>
<li>优先考虑泛型方法</li>
<li>利用有限制通配符来提高API的灵活性</li>
</ul>
<h2 id="6_枚举和注解">6 枚举和注解</h2>
<ul>
<li>用enum代替int常量</li>
<li>用实例域替代序数</li>
<li>用EnumSet代替位域</li>
<li>用EnumMap代替序数索引</li>
<li>用接口模拟可伸缩的枚举</li>
<li>注解优先于命名模式</li>
<li>坚持使用override注解</li>
<li>用标记接口定义类型</li>
</ul>
<h2 id="7_方法">7 方法</h2>
<ul>
<li>检查参数的有效性</li>
<li>必要时进行保护性拷贝</li>
<li>谨慎设计方法签名</li>
<li>慎用重载</li>
<li>慎用可变参数</li>
<li>返回零长度的数组或者集合，而不是null</li>
<li>为所有导出的API元素编写文档注释</li>
</ul>
<h2 id="8_通用程序设计">8 通用程序设计</h2>
<ul>
<li>将局部变量的作用域最小化</li>
<li>for-each循环优先于传统的for循环</li>
<li>了解和使用类库</li>
<li>如果要需要精确答案，请避免使用float和double</li>
<li>基本类型优先于装箱基本类型</li>
<li>如果其他类型更适合，则尽量避免使用字符串</li>
<li>当心字符串连接的性能</li>
<li>通过接口引用对象</li>
<li>接口优先于反射机制</li>
<li>谨慎地使用本地方法</li>
<li>谨慎地进行优化</li>
<li>遵守普遍接受的命名习惯</li>
</ul>
<h2 id="9_异常">9 异常</h2>
<ul>
<li>只针对异常的情况才使用异常</li>
<li>对可恢复的情况使用受检异常，对编程错误使用运行时异常</li>
<li>避免不必要地使用受检的异常</li>
<li>优先使用标准的异常</li>
<li>抛出与抽象相对应的异常</li>
<li>每个方法抛出的异常都要有文档</li>
<li>在细节消息中包含能捕获失败的信息</li>
<li>努力使失败保持原子性</li>
<li>不要忽略异常</li>
</ul>
<h2 id="10_并发">10 并发</h2>
<ul>
<li>同步访问共享的可变数据</li>
<li>避免过度同步</li>
<li>executor和task优先于线程</li>
<li>并发工具优先于wait和notify</li>
<li>线程安全性的文档化</li>
<li>慎用延迟初始化</li>
<li>不要依赖于线程调度器</li>
<li>避免使用线程组</li>
</ul>
<h2 id="11_序列化">11 序列化</h2>
<ul>
<li>谨慎地实现Serializable接口</li>
<li>考虑使用自定义的序列化形式</li>
<li>保护性地编写readObject方法</li>
<li>对于实力控制，枚举类型优先于readResolve</li>
<li>考略用序列化代理代替序列化实例</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>有关Effective 系列的书籍是建立在一定的项目经验的基础进行总结的，同样的，读者最好的在有一定的项目经验后阅读较为容易理解，但是即使没有经验同样收获也不少，同样地在每次完成项目之后来看会有一个质变的效果。</p>
<h2 id="2_创建与销毁对象">2 创建与销毁对]]>
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[集合浅尝]]></title>
    <link href="http://yoursite.com/2014/10/27/Collection/"/>
    <id>http://yoursite.com/2014/10/27/Collection/</id>
    <published>2014-10-27T10:28:07.000Z</published>
    <updated>2014-10-27T11:20:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="链表底层">链表底层</h3>
<p>链表寻找下一个元素一般是通过使用next方法。而这个方法的具体实现是，先跳到（指向）下一个数组，然后返回上一个元素。</p>
<pre><code><span class="type">Iterator</span>&lt;E&gt;    itr = c.<span class="keyword">iterator</span>();
c.next;
</code></pre><p><img src="/img/raw/2014-10-26/iterator.png" alt=""></p>
<p>所以要注意，在初始化之后，不能直接remove 需要先next后在remove</p>
<p><strong>对比</strong>C++:由于是通过数组储存，寻找目标可以直接通过索引(i++)访问。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="链表底层">链表底层</h3>
<p>链表寻找下一个元素一般是通过使用next方法。而这个方法的具体实现是，先跳到（指向）下一个数组，然后返回上一个元素。</p>
<pre><code><span class="type">Iterator</span>&lt;E]]>
    </summary>
    
      <category term="深度：*" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%EF%BC%9A/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android SQLite 用法]]></title>
    <link href="http://yoursite.com/2014/10/27/Andorid-sqlite/"/>
    <id>http://yoursite.com/2014/10/27/Andorid-sqlite/</id>
    <published>2014-10-27T10:28:07.000Z</published>
    <updated>2014-10-27T11:17:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="SQLite背景">SQLite背景</h2>
<p>SQLite是一个内嵌SQL数据库的引擎，与当前大部分的数据库不一样，不需要额外提供服务进程进行服务。所有读写只需一个磁盘文件进行存储即可。文件格式为跨平台，无论是64bit还是32bit、大小端输入均可。所以这个特征很适合作为applciation的文件格式。（参考 <a href="http://www.sqlite.org/about.html" target="_blank" rel="external">about SQLite</a>）</p>
<h2 id="SQLite用法">SQLite用法</h2>
<p>为了更为方便地在Android上使用，我们们把方法卸载onCreate里。code source(<a href="http://blog.csdn.net/liuhe688/article/details/6715983" target="_blank" rel="external">http://blog.csdn.net/liuhe688/article/details/6715983</a>)</p>
<pre><code>    <span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span>(Bundle savedInstanceState) {
    <span class="keyword">super</span>.onCreate(savedInstanceState);

    <span class="comment">//打开或创建test.db数据库</span>
    SQLiteDatabase db = openOrCreateDatabase(<span class="string">"test.db"</span>, Context.MODE_PRIVATE, <span class="keyword">null</span>);
    db.execSQL(<span class="string">"DROP TABLE IF EXISTS person"</span>);
    <span class="comment">//创建person表</span>
    db.execSQL(<span class="string">"CREATE TABLE person (_id INTEGER PRIMARY KEY AUTOINCREMENT, name VARCHAR, age SMALLINT)"</span>);
    Person person = <span class="keyword">new</span> Person();
    person.name = <span class="string">"john"</span>;
    person.age = <span class="number">30</span>;
    <span class="comment">//插入数据</span>
    db.execSQL(<span class="string">"INSERT INTO person VALUES (NULL, ?, ?)"</span>, <span class="keyword">new</span> Object[]{person.name, person.age});

    person.name = <span class="string">"david"</span>;
    person.age = <span class="number">33</span>;
    <span class="comment">//ContentValues以键值对的形式存放数据</span>
    ContentValues cv = <span class="keyword">new</span> ContentValues();
    cv.put(<span class="string">"name"</span>, person.name);
    cv.put(<span class="string">"age"</span>, person.age);
    <span class="comment">//插入ContentValues中的数据</span>
    db.insert(<span class="string">"person"</span>, <span class="keyword">null</span>, cv);

    cv = <span class="keyword">new</span> ContentValues();
    cv.put(<span class="string">"age"</span>, <span class="number">35</span>);
    <span class="comment">//更新数据</span>
    db.update(<span class="string">"person"</span>, cv, <span class="string">"name = ?"</span>, <span class="keyword">new</span> String[]{<span class="string">"john"</span>});

    Cursor c = db.rawQuery(<span class="string">"SELECT * FROM person WHERE age &gt;= ?"</span>, <span class="keyword">new</span> String[]{<span class="string">"33"</span>});
    <span class="keyword">while</span> (c.moveToNext()) {
        <span class="keyword">int</span> _id = c.getInt(c.getColumnIndex(<span class="string">"_id"</span>));
        String name = c.getString(c.getColumnIndex(<span class="string">"name"</span>));
        <span class="keyword">int</span> age = c.getInt(c.getColumnIndex(<span class="string">"age"</span>));
        Log.i(<span class="string">"db"</span>, <span class="string">"_id=&gt;"</span> + _id + <span class="string">", name=&gt;"</span> + name + <span class="string">", age=&gt;"</span> + age);
    }
    c.close();

    <span class="comment">//删除数据</span>
    db.delete(<span class="string">"person"</span>, <span class="string">"age &lt; ?"</span>, <span class="keyword">new</span> String[]{<span class="string">"35"</span>});

    <span class="comment">//关闭当前数据库</span>
    db.close();

    <span class="comment">//删除test.db数据库</span>
<span class="comment">//        deleteDatabase("test.db");</span>
}
</code></pre><p>执行完代码之后，会生成相关的数据库文件（.db）。如上文的代码会生成 /data/data/com.example.test/databases/test.db </p>
<h3 id="在一般的项目的开发中，我们会把相关的项目工具类封装好（MVC）。">在一般的项目的开发中，我们会把相关的项目工具类封装好（MVC）。</h3>
<p>DBHelper.java(数据库的生成)</p>
<p>DBManager.java(数据库的管理)</p>
<p><img src="/img/raw/2014-10-26/DB.png" alt=""></p>
<p>博文参考：<a href="http://blog.csdn.net/liuhe688/article/details/6715983" target="_blank" rel="external">http://blog.csdn.net/liuhe688/article/details/6715983</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="SQLite背景">SQLite背景</h2>
<p>SQLite是一个内嵌SQL数据库的引擎，与当前大部分的数据库不一样，不需要额外提供服务进程进行服务。所有读写只需一个磁盘文件进行存储即可。文件格式为跨平台，无论是64bit还是32bit、大小端输入均可。所以]]>
    </summary>
    
      <category term="深度：*" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%EF%BC%9A/"/>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[博客搬家]]></title>
    <link href="http://yoursite.com/2014/10/27/bloglist/"/>
    <id>http://yoursite.com/2014/10/27/bloglist/</id>
    <published>2014-10-27T10:28:07.000Z</published>
    <updated>2014-10-27T10:32:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="CSDN博客（旧）_http://blog-csdn-net/aaronplay">CSDN博客（旧） <a href="http://blog.csdn.net/aaronplay" target="_blank" rel="external">http://blog.csdn.net/aaronplay</a></h2>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="CSDN博客（旧）_http://blog-csdn-net/aaronplay">CSDN博客（旧） <a href="http://blog.csdn.net/aaronplay" target="_blank" rel="external">http://b]]>
    </summary>
    
      <category term="Doc" scheme="http://yoursite.com/categories/Doc/"/>
    
  </entry>
  
</feed>
